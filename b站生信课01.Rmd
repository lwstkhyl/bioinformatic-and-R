---
title: "b站生信课01"
output: html_document
date: "2024-07-16"
---

使用GEOquery包下载GEO数据
```{r}
library(GEOquery);
geo_set <- getGEO(
  filename = "GSE65858_series_matrix.txt.gz",
  destdir = '.',
  AnnotGPL = F,
  getGPL = F
);
geo_set2 <- getGEO(
  GEO = "GSE65858",
  destdir = '.',
  AnnotGPL = F,
  getGPL = F
);
# 展示数据
expr <- exprs(geo_set);
pd <- pData(geo_set);
```

读取counts数据
```{r}
library(data.table);
counts1 <- fread("C:\\Users\\17185\\Desktop\\r-markdown\\R实战\\data\\TCGA-HNSC.htseq_counts.tsv.gz");  # 读取数据
# 因为是.gz格式，所以用fread函数，正常就是read_tsv
head(counts);
```

从官网上可知，这里的counts是log2处理后的，一般情况下需要转成原始值再分析
```{r}
library(tidyverse)
counts1 <- column_to_rownames(counts1, "Ensembl_ID")  # 将各基因id转为列名，其它列作为行名
head(counts1)
```

现在要把处理后的counts进行2^n^操作
```{r}
counts2 <- 2 ^ counts1 - 1;
#因为counts无小数，为防止逆转过程中精度损失，需要进行取整操作
counts <- round(counts2);
head(counts);
```
为什么要2^n^后再-1？
因为从数据库下载下来的counts值，是通过log2对数转换了的，转换之前的原始counts值，有很多值为0，而以2为底，对0进行对数转换的话，是无意义的，数学上也无法转换，所以通常我们在进行log2转换之前，需要先将原始的counts值+1，然后进行对数转换
在counts中，行名为基因id，列名为样本名

读取生存数据和临床数据
```{r}
survival_data <- read_tsv("C:\\Users\\17185\\Desktop\\r-markdown\\R实战\\data\\TCGA-HNSC.survival.tsv");  # 生存数据
head(survival_data);
clinical_data <- fread("C:\\Users\\17185\\Desktop\\r-markdown\\R实战\\data\\TCGA-HNSC.GDC_phenotype.tsv.gz");  # 临床数据
head(clinical_data)
```
生存数据中有样本名sample、阳性事件os等列

过滤掉没有生存数据或者没有表达数据的样本，即对counts和survival_data的样本名取交集
```{r}
expr_sample <- colnames(counts);  # 表达数据的行名（样本名）
surv_sample <- survival_data$sample;  # 生存数据的样本名
valid_sample <- intersect(expr_sample, surv_sample);  # 取交集，得到既有生存数据也有表达数据的样本
counts <- counts[, valid_sample];  # 取出这些样本（根据列名）
head(counts);
survival_data <- column_to_rownames(survival_data, "sample");  # 样本名的列变行名，方便取出样本
surv_data <- survival_data[valid_sample, ];  # 取出这些样本（根据行名）
head(surv_data);
```
现在我们的表达数据是counts，有545个数据；生存数据是surv_data，也有545个数据

过滤掉非肿瘤样本
[TCGA中样本编号命名规则](https://zhuanlan.zhihu.com/p/564801425)
由此需要让样本编号最后三位是01-09的保留
```{r}
sample_type <- str_split(colnames(counts), pattern = '-', n = 4, simplify = TRUE);
# pattern指定分隔符，n指定分隔成几部分，simplify指定是否将分隔结果组合成向量级
sample_type <- as.data.frame(sample_type);  # 转成df
head(sample_type);
sample_type <- sample_type[, 'V4'];  # 只取最后的V4列
unique(sample_type);  # "01A" "11A" "01B" "06A"
```

为直观展示是不是肿瘤组织，我们想让"11A"->"normal"，另三种->"tumor"
```{r}
sample_type <- ifelse(sample_type == "11A", "normal", "tumor");
sample_type <- as.data.frame(sample_type);
head(sample_type);
```

因为counts和surv_data都是直接根据valid_sample取的，所以它们的数据顺序相同，而sample_type是根据counts取的，所以它可以直接应用在surv_data上
```{r}
is_tumor <- sample_type[, 1] == "tumor";
head(is_tumor);  # is_tumor是由bool值组成的vector，第n个元素说明counts中第n列和surv_data中第n行是不是tumor数据
tumor_counts <- counts[, is_tumor];  # 根据bool值取列
tumor_surv <- surv_data[is_tumor, ];  # 根据bool值取行 
head(tumor_counts);
head(tumor_surv);
```
为方便查看数据，将所有的基因id转化成基因名
注：基因id中`.`后的没有用
```{r}
gene_id <- rownames(tumor_counts);
gene_id <- str_split(gene_id, pattern = '[.]', simplify = TRUE);  # 为避免'.'被识别成正则表达式，使用'[.]'
head(gene_id);
gene_id <- gene_id[, 1]  # 只取第一列（'.'前的部分）
head(gene_id);
```

使用`org.Hs.eg.db`包将基因id转成基因名
```{r}
if(!require("org.Hs.eg.db", quietly = T))
{
  library("BiocManager");
  BiocManager::install("org.Hs.eg.db");
}
```

```{r}
gene_name <- mapIds(org.Hs.eg.db, gene_id, "SYMBOL", "ENSEMBL");
view(gene_name);
rownames(tumor_counts) <- gene_name;  # 更改counts表的行名（基因id）
view(tumor_counts);
```
另一种方式：不仅可以更改counts表的行名，还能同时让相同的基因对应的表达量合并（取平均值）。
因为多个基因id可能对应着相同的基因名称，而在counts表中，这些基因id的表达量不同，在转化为基因名称时，为了不让同一个基因名称有多个表达量，需要进行合并操作

```{r}
https://www.bilibili.com/video/BV1qF4m157zX
# 也可以将counts表行名变列名后，与gene_name表进行连接(join函数)



