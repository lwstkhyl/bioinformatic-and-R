<a id="mulu">目录</a>
<a href="#mulu" class="back">回到目录</a>
<style>
    .back{width:40px;height:40px;display:inline-block;line-height:20px;font-size:20px;background-color:lightyellow;position: fixed;bottom:50px;right:50px;z-index:999;border:2px solid pink;opacity:0.3;transition:all 0.3s;color:green;}
    .back:hover{color:red;opacity:1}
    img{vertical-align:bottom;}
</style>

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [并行计算](#并行计算)
- [ggplot2](#ggplot2)

<!-- /code_chunk_output -->

<!-- 打开侧边预览：f1->Markdown Preview Enhanced: open...
只有打开侧边预览时保存才自动更新目录 -->

写在前面：本篇内容及例子（除标注了参考文章/具体案例的部分，以及一些比较零碎的小知识点）均来自[华中科技大学--组学数据分析与可视化课程--大二上](https://github.com/evolgeniusteam/R-for-bioinformatics) | [关于本课程的复习资料](https://github.com/Lucas04-nhr/Review-of-R) | [课程作业答案](https://github.com/Lucas04-nhr/R-for-Data-Science/tree/main/Exercises%20and%20homework) | [课程作业答案--中文注释版](https://github.com/lwstkhyl/r_class_homework)

### 并行计算
即同时执行多个计算任务以加速整体的处理速度，通过在多个处理器或多个计算节点上同时执行代码来实现
一般需要**3个步骤**：
- 分解并发放任务
- 分别计算
- 回收结果并保存
**相关的包**：
- `parallel`包：显示CPU core数量，将全部或部分CPU核心分配给任务。在任务完成后，要回收分配的CPU core
- `foreach`包：提供`%do%`和`%dopar%`操作符，以提交任务，进行顺序或并行计算
- 辅助包`iterators`：将data.frame、tibble、matrix等数据结构分割为行/列，用于提交并行任务

```
install.packages( "parallel" );
install.packages( "foreach" );  # 会自动安装 iterators 
```

---

一个简单的例子：
```
library(parallel); 
library(foreach);
library(iterators);
# 检测有多少个CPU core
cpus <- parallel::detectCores();  # 返回一个整数，表示CPU core数量
# 创建一个data.frame 
d <- data.frame(x=1:10, y=rnorm(10));
# 创造一个cluster集群进行计算
cl <- makeCluster( cpus - 1 );
# 分配任务
res <- foreach( row = iter( d, by = "row" ) ) %dopar% {
  return ( row$x * row$y  );
}
# 注意在最后关闭创建的cluster，释放资源
stopCluster( cl );
```
补充说明：
```
res <- foreach( row = iter( d, by = "row" ) ) %dopar% {
  return ( row$x * row$y  );
}
```
其中
- `row = iter( d, by = "row" )`表示将输入数据`d`按行row或列col遍历，每次取出一行/一列，赋予`row`这个变量（可随意取名）
- `foreach`函数将数据`row`分发给`cl`（这里没有体现出来），进行计算`row$x * row$y`，并返回结果
- `.combine = 'c'`参数规定将返回结果合并为vector
  该参数的可能值：
  - `'c'`将返回值合并为vector，当返回值是单个数字或字符串的时候使用
  - `'cbind'`将返回值按列合并
  - `'rbind'`将返回值按行合并
  - 默认情况下返回list

---

**`foreach`函数的其它参数**`.packages=NULL`：将需要的包传递给任务，例如当每个任务需要提前装入tidyverse包时，可以`.packages=c("tidyverse")`
**嵌套`foreach`**：有些情况下需要用到嵌套循环，使用以下语法--
```
foreach( ... ) %:% {
  foreach( ... ) %dopar% {
    # 语句
  }
}
```
即外层的循环部分用`%:%`操作符

---

例：将下面的计算转为并行计算
```
mtcars %>% 
    split( .$cyl ) %>% 
    map( ~ cor.test( .$wt, .$mpg ) ) %>% 
    map_dbl( ~.$estimate );
```
运行结果为：
```
         4          6          8 
-0.7131848 -0.6815498 -0.6503580 
```
使用并行计算：
```
cpus <- parallel::detectCores();
cl2 <- makeCluster( cpus - 1 );
res2 <- foreach( 
    df = iter(  mtcars %>% split( .$cyl )  ), 
    .combine = 'rbind' 
    ) %dopar% {
        cor.res <- cor.test( df$wt, df$mpg );
        return ( c(cor.res$estimate, cor.res$p.value) );  #注意这里的返回值是vector
    }
res2;
```
- `df = iter(mtcars %>% split( .$cyl ))`：将mtcars按汽缸数cyl分割为3个list，依次赋予`df`
- `cor.res <- cor.test(df$wt, df$mpg);`：计算每个`df`中wt与mpg的关联，将结果保存在`cor.res`变量中
- `.combine = 'rbind'`：由于返回值是vector，用此命令按行合并

运行结果为：
```
                cor           
result.1 -0.7131848 0.01374278
result.2 -0.6815498 0.09175766
result.3 -0.6503580 0.01179281
```
其中第二列是p值，第一列就是上面普通计算得到的结果

---

其它并行计算函数：`parallel`包本身也提供了`lapply`等函数的并行计算版本，包括`parLapply`、`parSapply`、`parRapply`、`parCapply`等
例：计算2的N次方
```
cl<-makeCluster(3);
parLapply(
  cl,  # 使用cl集群计算
  2:4,  # 要遍历的数据
  function(exponent)  # 将每个元素传给exponent
    2^exponent  # 返回2的exponent次方
);
stopCluster(cl);
```
运行结果为一个列表：
```
[[1]]
[1] 4

[[2]]
[1] 8

[[3]]
[1] 16
```
### ggplot2
[参考文章](https://zhuanlan.zhihu.com/p/503881951)
