<a id="mulu">目录</a>
<a href="#mulu" class="back">回到目录</a>
<style>
    .back{width:40px;height:40px;display:inline-block;line-height:20px;font-size:20px;background-color:lightyellow;position: fixed;bottom:50px;right:50px;z-index:999;border:2px solid pink;opacity:0.3;transition:all 0.3s;color:green;}
    .back:hover{color:red;opacity:1}
    img{vertical-align:bottom;}
</style>

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [管道运算符pipe](#管道运算符pipe)
    - [向右操作符](#向右操作符)
    - [向左操作符](#向左操作符)
    - [解释操作符](#解释操作符)
    - [复合赋值操作符](#复合赋值操作符)

<!-- /code_chunk_output -->

<!-- 打开侧边预览：f1->Markdown Preview Enhanced: open...
只有打开侧边预览时保存才自动更新目录 -->

### 管道运算符pipe
由`magrittr`包提供
##### 向右操作符
`%>%`向右操作符（最常用），把左侧的数据或表达式，传递给右侧的函数调用或表达式进行运行，可以连续操作
快捷键：`CTRL`+`shift`+`M`
在右侧函数中，可以用`.`指代传递来的数据，也可以省略不写，默认放入右侧（外层）函数的第一个参数位置
如果右侧是一个嵌套函数，我们要在内层函数中使用传递来的数据，就必须用`.`指代
```
swiss %>% do( head(., n = 4 ) );
swiss %>% head(., n = 4 );
swiss %>% head( n = 4 );
swiss %>% do( head( n = 4 ) );  # x被传到了do函数内，head未接收到x，报错
```
##### 向左操作符
`%T>%`向左操作符，把左侧的数据传给右侧函数调用或表达式，并将**左侧**的数据作为结果
`a %T>% func()`的结果为`a`，而`a %>% func()`的结果为`func(a)`，它们都会执行一次`func(a)`，只是`a %T>% func()`整体的值不同
例：
```
res <- 
  rnorm(100) %>%
    matrix(ncol = 2) %T>%
    plot();  # 都会画图
res  # 一个matrix
res2 <- 
  rnorm(100) %>%
    matrix(ncol = 2) %T>%
    plot();
res2  # 一个plot()图片
```
##### 解释操作符
`%$%`解释操作符，把左侧数据的属性名传给右侧，让右侧的调用函数直接通过名字，就可以获取左侧的数据
作用可类比`attach()`和`with()`
```
mtcars %$% 
  cor.test( cyl, mpg );  # 相当于
attach( mtcars );
cor.test( cyl, mpg );  # 相当于
with( mtcars, cor.test( cyl, mpg ) );
```
##### 复合赋值操作符
`%<>%`复合赋值操作符，功能可类比`%>%`，多了一项额外的操作，就是把结果写回到最左侧的对象（覆盖原来的值）
```
x<-rnorm(10);
x %>% abs %>% sort;
x;  # 取绝对值、排序之后的结果并没有直接写到x
x %<>% abs %>% sort;
x;  # 取绝对值、排序之后的结果直接覆盖掉了原来的x
```

---

在实际应用中，尽量使用方向明确的`%>%`，而不使用其它方向不明确的pipe
