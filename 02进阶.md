<a id="mulu">目录</a>
<a href="#mulu" class="back">回到目录</a>
<style>
    .back{width:40px;height:40px;display:inline-block;line-height:20px;font-size:20px;background-color:lightyellow;position: fixed;bottom:50px;right:50px;z-index:999;border:2px solid pink;opacity:0.3;transition:all 0.3s;color:green;}
    .back:hover{color:red;opacity:1}
    img{vertical-align:bottom;}
</style>

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [管道运算符pipe](#管道运算符pipe)
    - [向右操作符](#向右操作符)
    - [向左操作符](#向左操作符)
    - [解释操作符](#解释操作符)
    - [复合赋值操作符](#复合赋值操作符)
    - [%in%](#in)
- [dplyr包](#dplyr包)
    - [arrange](#arrange)
    - [select](#select)
    - [filter](#filter)
    - [mutate](#mutate)
    - [summarise与group_by](#summarise与group_by)
    - [其它取行操作](#其它取行操作)
    - [实际案例](#实际案例)
      - [行的使用](#行的使用)
      - [列的使用](#列的使用)
      - [基因分析](#基因分析)

<!-- /code_chunk_output -->

<!-- 打开侧边预览：f1->Markdown Preview Enhanced: open...
只有打开侧边预览时保存才自动更新目录 -->

### 管道运算符pipe
由`magrittr`包提供
##### 向右操作符
`%>%`向右操作符（最常用），把左侧的数据或表达式，传递给右侧的函数调用或表达式进行运行，可以连续操作
快捷键：`CTRL`+`shift`+`M`
在右侧函数中，可以用`.`指代传递来的数据，也可以省略不写，默认放入右侧（外层）函数的第一个参数位置
如果右侧是一个嵌套函数，我们要在内层函数中使用传递来的数据，就必须用`.`指代
```
swiss %>% do( head(., n = 4 ) );
swiss %>% head(., n = 4 );
swiss %>% head( n = 4 );
swiss %>% do( head( n = 4 ) );  # x被传到了do函数内，head未接收到x，报错
```
##### 向左操作符
`%T>%`向左操作符，把左侧的数据传给右侧函数调用或表达式，并将**左侧**的数据作为结果
`a %T>% func()`的结果为`a`，而`a %>% func()`的结果为`func(a)`，它们都会执行一次`func(a)`，只是`a %T>% func()`整体的值不同
例：
```
res <- 
  rnorm(100) %>%
    matrix(ncol = 2) %T>%
    plot();  # 都会画图
res  # 一个matrix
res2 <- 
  rnorm(100) %>%
    matrix(ncol = 2) %T>%
    plot();
res2  # 一个plot()图片
```
##### 解释操作符
`%$%`解释操作符，把左侧数据的属性名传给右侧，让右侧的调用函数直接通过名字，就可以获取左侧的数据
作用可类比`attach()`和`with()`
```
mtcars %$% 
  cor.test( cyl, mpg );  # 相当于
attach( mtcars );
cor.test( cyl, mpg );  # 相当于
with( mtcars, cor.test( cyl, mpg ) );
```
##### 复合赋值操作符
`%<>%`复合赋值操作符，功能可类比`%>%`，多了一项额外的操作，就是把结果写回到最左侧的对象（覆盖原来的值）
```
x<-rnorm(10);
x %>% abs %>% sort;
x;  # 取绝对值、排序之后的结果并没有直接写到x
x %<>% abs %>% sort;
x;  # 取绝对值、排序之后的结果直接覆盖掉了原来的x
```

---

在实际应用中，尽量使用方向明确的`%>%`，而不使用其它方向不明确的pipe
##### %in%
判断它左边的向量是否在右边的向量中
```
a <- 1:10
b <- c(1,3,5,9)
a %in% b
# TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE
```
即依次判断1在不在`c(1,3,5,9)`中、2在不在`c(1,3,5,9)`中、...
取a、b交集：
```
a[a %in% b]
```
与ifelse和which结合：
```
ifelse(a %in% 1, 1, 0) #若a的值包含在1里面，输出1，否者输出0
# 1 0 0 0 0 0 0 0 0 0
```
```
which(a %in% 1) #输出x包含在1中值的位置
# 1
```
### dplyr包
[参考文章](https://zhuanlan.zhihu.com/p/150457098)
类似于python中的pandas，能对dataframe/tb类型的数据做很方便的数据处理和分析操作
本节中使用的例子：`aapl`表
![dplyr包例](https://pic3.zhimg.com/80/v2-1696feb42a0ec512564b9253cdc918a2_1440w.webp "dplyr包例"){:width=250 height=250}
##### arrange
`arrange(a, b)`对a数据按照其中b列的值进行升序排序
`arrange(a, -b)`对a数据按照其中b列的值进行降序排序
dplyr包的函数通常与[管道运算符](#管道运算符pipe)联用，写成`a %>% arrange(-b)`的形式
例：
```
aapl %>% arrange(-Volume)
```
![arrange例](https://pic3.zhimg.com/80/v2-7a7ff1d473c51bdcb3fe7be59067507e_1440w.webp "arrange例"){:width=250 height=250}
##### select
`a %>% select(列名1,列名2,...)`选取a中指定的列
例：
```
aapl %>% select(Date, Close, Volume)
```
![select例](https://pic4.zhimg.com/80/v2-fc2bf3c3ab49370fff87cc8a8aadf7eb_1440w.webp "select例"){:width=250 height=250}
另外一种表达方式：`a %>% select(-c(列名1,列名2,...))`排除这些列，选取剩下的列
```
aapl %>% select(-c("Open", "High", "Low")) 
```
得到相同的结果

---

也可以传入一个函数判断式，用来选择符合条件的列名
```
starwars %>% 
  select( name, ends_with("color") );
```
表示选出以"color"结尾的列名
其它的操作：
- `select(data, starts_with("Sepal"))`选择以"Sepal"开头的所有列
- `select(data, Sepal.Length:Petal.Width)`选择"Sepal.Length"与"Petal.Width"之间的所有列
- `select(data, contains("."))`选择名称包含"."的列
- `select(data, matches("正则表达式"))`选择名称与正则表达式匹配的列
- `select(data, num_range("x", 1:5))`选择名为x1、x2、x3、x4、x5的列
- `select(data, one_of(c("Species", "Genus")))`选择名称在一组名称中的列
- `select(data, everything())`选择每一列
##### filter
`a %>% filter(条件表达式)`选取a中符合条件的行，条件表达式中一般用列名进行判断
例：
```
aapl %>% filter(Close>=150)  # 选择close列>=150的行
```
![filter例](https://pic2.zhimg.com/80/v2-5c508445f6a0615f4aa1ce571cb4498d_1440w.webp "filter例"){:width=250 height=250}
```
aapl %>% filter((Close>=150) & (Close>Open))  # 选择close列>=150且close列值>open列值的行
```
![filter例2](https://pic1.zhimg.com/80/v2-5716ef22b4f9fb3ec55fa18653338e80_1440w.webp "filter例2"){:width=250 height=250}
##### mutate
`a %>% mutate(新列1=列运算,...)`将现有的列经过计算后生成新列
例：
```
# 将High列减去Low列的结果定义为maxDif，并取log
aapl %>% mutate(maxDif = High-Low,
                log_maxDif=log(maxDif)) 
```
![mutate例](https://pic3.zhimg.com/80/v2-89c6be2e5ccb561814d2c0038848109a_1440w.webp "mutate例"){:width=250 height=250}
```
aapl %>% mutate(n=row_number())  # 为每行数据添加行数标记
```
![mutate例1](https://pic2.zhimg.com/80/v2-393309418ce8e61624dae3d46ead0d41_1440w.webp "mutate例1"){:width=250 height=250}
其它的mutate函数：
- `transmute(新列1=列运算,...)`类似`mutate`，区别是它会删除使用过的就列
- `mutate_each(funs(列处理函数),c(列名1,列名2,...))`对每列/指定列执行给定的函数
  ```
  data %>% mutate_each(funs(as.numeric), c("dbl1","dbl2","dbl3"))
  ```
  表示将"dbl1","dbl2","dbl3"三列变成数值型
##### summarise与group_by
`a %>% group_by(列1,列2,...)`按指定列分组，有相同列值的行为同一组
`a %>% summarise(新列1=列运算,...)`将多个值转换为单个值（通过`mean平均值`、`median中位数`、`n_distinct计算每组行数`等操作），生成新列（总行数减少，通常与`group_by`配合使用），结果中每一组的计算结果为一行
例：weather数据集
![summarise与group_by](https://pic1.zhimg.com/80/v2-56fc33210797fe9138bf7c8c09778d64_1440w.webp "summarise与group_by"){:width=250 height=250}
```
# 按city分组，计算温度的平均值，存入新列mean_temperature中
weather %>% group_by(city) %>% summarise(mean_temperature = mean(temperature))
```
![summarise与group_by例](https://pic4.zhimg.com/80/v2-ce6b704c8ee6890847a60141350938cb_1440w.webp "summarise与group_by例"){:width=125 height=125}
当不指定分组，直接summarise时，按所有数据为一组，即计算所有数据的平均值等
```
weather %>% summarise(mean_temperature = mean(temperature))
```
![summarise与group_by例2](https://pic2.zhimg.com/80/v2-7717371178297f50bd21a046e18b9a79_1440w.webp "summarise与group_by例2"){:width=100 height=100}

更多的列运算：
![列运算](./md-image/列运算.png "列运算"){:width=200 height=200}
##### 其它取行操作
- `distinct(data)`删除重复行
- `sample_frac(data, 0.5, replace = TRUE)`随机选择部分行
- `sample_n(data, 10, replace = TRUE)`随机选择n行
- `slice(data, 10:15)`按位置选择行
- `top_n(data, n, 列名)`选择前n行，并按指定列排序（如果数据分组，则按组）
##### 实际案例
###### 行的使用
给定tb`grades.melted`
```
grades <- tibble( "Name" = c("Weihua Chen", "Mm Hu", "John Doe", "Jane Doe","Warren Buffet", "Elon Musk", "Jack Ma"),
                  "Occupation" = c("Teacher", "Student", "Teacher", "Student", rep( "Entrepreneur", 3 ) ),
                  "English" = sample( 60:100, 7 ),
                  "ComputerScience" = sample(80:90, 7),
                  "Biology" = sample( 50:100, 7),
                  "Bioinformatics" = sample( 40:90, 7));
grades.melted <- grades %>% 
  gather( course, grade, -Name, -Occupation, na.rm = T );
```
![成绩分析](./md-image/成绩分析.png "成绩分析"){:width=200 height=200}
观察数据可以看到，每人都有很多门科目
- 求出每个人的平均成绩，并排序
  ```
  grades.melted %>% 
    group_by(Name, Occupation) %>%  # 按姓名/职位分组，即选出每人的各科成绩
    summarise( avg_grades = mean( grade )) %>%  # 将结果保存在avg_grades列
    arrange( -avg_grades );  # 降序排序
  ```
- 将每个人的分数排序
  ```
  grades.melted %>% 
  arrange( Name, -grade );  # 相当于先按Name排序，再排各Name中的grade
  ```
  ![成绩分析1](./md-image/成绩分析1.png "成绩分析1"){:width=200 height=200}
- 求出每个人的最好科目及其成绩（在上面的基础上）
  ```
  grades.melted %>% 
    arrange( Name, -grade ) %>%
    group_by( Name ) %>%  # 按姓名分组
    summarise( best_course = first( course ),  # 每组best_course值为第一个course
              best_grade = first( grade ),  # 每组best_grade值为第一个grade
              avg_grades = mean( grade ) )
  ```
  为什么是第一个course/grade？因为在`arrange( Name, -grade )`已经对每人的成绩排好序了，第一个就是最高的成绩
  ![成绩分析2](./md-image/成绩分析2.png "成绩分析2"){:width=120 height=120}
###### 列的使用
使用R中自带数据集`starwars`
- 取出相关列，用于计算人物的BMI
  ```
  starwars %>% 
  select( name, height, mass ) %>%
  mutate( bmi = mass / ( (height / 100 ) ^ 2 ) ) ;
  ```
- 获取与颜色相关的列: hair_color, skin_color, eye_color
  ```
  starwars %>% 
    select( name, ends_with("color") );
  ```
- 挑选金发碧眼的人物
  ```
  starwars %>% 
    select( name, ends_with("color"), gender, species ) %>% 
    filter( hair_color == "blond" & eye_color == "blue" )
  ```
###### 基因分析
使用tb`mouse.tibble`，共6列：
![基因分析](./md-image/基因分析.png "基因分析"){:width=200 height=200}
![基因分析2](./md-image/基因分析2.png "基因分析2"){:width=100 height=100}
例1：
1. 处理行：将染色体限制在常染色体和XY上（去掉未组装的小片段）
2. 处理行：将基因类型限制在 protein_coding, miRNA和 lincRNA 这三种
3. 新增列：统计每条染色体上不同类型基因（protein_coding, miRNA, lincRNA）的数量
4. 按染色体（正）、基因数量（倒）进行排序

```
mouse.tibble %>% 
  ## 1. 
  filter( `Chromosome/scaffold name` %in% c( 1:19, "X", "Y" )   ) %>% 
  ## 2. 
  filter( `Transcript type` %in% c( "protein_coding", "miRNA", "lincRNA" ) ) %>%
  ## 改变列的名称，方便后续处理列 
  select( CHR = `Chromosome/scaffold name`, TYPE = `Transcript type`, 
          GENE_ID = `Gene stable ID`, 
          GENE_LEN =  `Transcript length (including UTRs and CDS)`  ) %>%
  ## 3.
  ## 按染色体和基因类型分组，因为要统计"每条染色体上"不同类型基因
  group_by( CHR, TYPE ) %>% 
  ## 使用n_distinct计算数量，mean计算平均值
  summarise( count = n_distinct( GENE_ID ), mean_len = mean( GENE_LEN ) ) %>% 
  ## 4. 
  arrange(  CHR  , desc( count ) );
```
