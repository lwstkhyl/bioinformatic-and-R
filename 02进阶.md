<a id="mulu">目录</a>
<a href="#mulu" class="back">回到目录</a>
<style>
    .back{width:40px;height:40px;display:inline-block;line-height:20px;font-size:20px;background-color:lightyellow;position: fixed;bottom:50px;right:50px;z-index:999;border:2px solid pink;opacity:0.3;transition:all 0.3s;color:green;}
    .back:hover{color:red;opacity:1}
    img{vertical-align:bottom;}
</style>

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [管道运算符pipe](#管道运算符pipe)
    - [向右操作符](#向右操作符)
    - [向左操作符](#向左操作符)
    - [解释操作符](#解释操作符)
    - [复合赋值操作符](#复合赋值操作符)
    - [%in%](#in)
- [dplyr包](#dplyr包)
    - [arrange](#arrange)
    - [select](#select)
    - [filter](#filter)
    - [mutate](#mutate)
    - [summarise与group_by](#summarise与group_by)

<!-- /code_chunk_output -->

<!-- 打开侧边预览：f1->Markdown Preview Enhanced: open...
只有打开侧边预览时保存才自动更新目录 -->

### 管道运算符pipe
由`magrittr`包提供
##### 向右操作符
`%>%`向右操作符（最常用），把左侧的数据或表达式，传递给右侧的函数调用或表达式进行运行，可以连续操作
快捷键：`CTRL`+`shift`+`M`
在右侧函数中，可以用`.`指代传递来的数据，也可以省略不写，默认放入右侧（外层）函数的第一个参数位置
如果右侧是一个嵌套函数，我们要在内层函数中使用传递来的数据，就必须用`.`指代
```
swiss %>% do( head(., n = 4 ) );
swiss %>% head(., n = 4 );
swiss %>% head( n = 4 );
swiss %>% do( head( n = 4 ) );  # x被传到了do函数内，head未接收到x，报错
```
##### 向左操作符
`%T>%`向左操作符，把左侧的数据传给右侧函数调用或表达式，并将**左侧**的数据作为结果
`a %T>% func()`的结果为`a`，而`a %>% func()`的结果为`func(a)`，它们都会执行一次`func(a)`，只是`a %T>% func()`整体的值不同
例：
```
res <- 
  rnorm(100) %>%
    matrix(ncol = 2) %T>%
    plot();  # 都会画图
res  # 一个matrix
res2 <- 
  rnorm(100) %>%
    matrix(ncol = 2) %T>%
    plot();
res2  # 一个plot()图片
```
##### 解释操作符
`%$%`解释操作符，把左侧数据的属性名传给右侧，让右侧的调用函数直接通过名字，就可以获取左侧的数据
作用可类比`attach()`和`with()`
```
mtcars %$% 
  cor.test( cyl, mpg );  # 相当于
attach( mtcars );
cor.test( cyl, mpg );  # 相当于
with( mtcars, cor.test( cyl, mpg ) );
```
##### 复合赋值操作符
`%<>%`复合赋值操作符，功能可类比`%>%`，多了一项额外的操作，就是把结果写回到最左侧的对象（覆盖原来的值）
```
x<-rnorm(10);
x %>% abs %>% sort;
x;  # 取绝对值、排序之后的结果并没有直接写到x
x %<>% abs %>% sort;
x;  # 取绝对值、排序之后的结果直接覆盖掉了原来的x
```

---

在实际应用中，尽量使用方向明确的`%>%`，而不使用其它方向不明确的pipe
##### %in%
判断它左边的向量是否在右边的向量中
```
a <- 1:10
b <- c(1,3,5,9)
a %in% b
# TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE
```
即依次判断1在不在`c(1,3,5,9)`中、2在不在`c(1,3,5,9)`中、...
取a、b交集：
```
a[a %in% b]
```
与ifelse和which结合：
```
ifelse(a %in% 1, 1, 0) #若a的值包含在1里面，输出1，否者输出0
# 1 0 0 0 0 0 0 0 0 0
```
```
which(a %in% 1) #输出x包含在1中值的位置
# 1
```
### dplyr包
[参考文章](https://zhuanlan.zhihu.com/p/150457098)
类似于python中的pandas，能对dataframe/tb类型的数据做很方便的数据处理和分析操作
本节中使用的例子：`aapl`表
![dplyr包例](https://pic3.zhimg.com/80/v2-1696feb42a0ec512564b9253cdc918a2_1440w.webp "dplyr包例"){:width=250 height=250}
##### arrange
`arrange(a, b)`对a数据按照其中b列的值进行升序排序
`arrange(a, -b)`对a数据按照其中b列的值进行降序排序
dplyr包的函数通常与[管道运算符](#管道运算符pipe)联用，写成`a %>% arrange(-b)`的形式
例：
```
aapl %>% arrange(-Volume)
```
![arrange例](https://pic3.zhimg.com/80/v2-7a7ff1d473c51bdcb3fe7be59067507e_1440w.webp "arrange例"){:width=250 height=250}
##### select
`a %>% select(列名1,列名2,...)`选取a中指定的列
例：
```
aapl %>% select(Date, Close, Volume)
```
![select例](https://pic4.zhimg.com/80/v2-fc2bf3c3ab49370fff87cc8a8aadf7eb_1440w.webp "select例"){:width=250 height=250}
另外一种表达方式：`a %>% select(-c(列名1,列名2,...))`排除这些列，选取剩下的列
```
aapl %>% select(-c("Open", "High", "Low")) 
```
得到相同的结果
##### filter
`a %>% filter(条件表达式)`选取a中符合条件的行，条件表达式中一般用列名进行判断
例：
```
aapl %>% filter(Close>=150)  # 选择close列>=150的行
```
![filter例](https://pic2.zhimg.com/80/v2-5c508445f6a0615f4aa1ce571cb4498d_1440w.webp "filter例"){:width=250 height=250}
```
aapl %>% filter((Close>=150) & (Close>Open))  # 选择close列>=150且close列值>open列值的行
```
![filter例2](https://pic1.zhimg.com/80/v2-5716ef22b4f9fb3ec55fa18653338e80_1440w.webp "filter例2"){:width=250 height=250}
##### mutate
`a %>% mutate(新列1=列运算,...)`将现有的列经过计算后生成新列
例：
```
# 将High列减去Low列的结果定义为maxDif，并取log
aapl %>% mutate(maxDif = High-Low,
                log_maxDif=log(maxDif)) 
```
![mutate例](https://pic3.zhimg.com/80/v2-89c6be2e5ccb561814d2c0038848109a_1440w.webp "mutate例"){:width=250 height=250}
```
aapl %>% mutate(n=row_number())  # 为每行数据添加行数标记
```
![mutate例1](https://pic2.zhimg.com/80/v2-393309418ce8e61624dae3d46ead0d41_1440w.webp "mutate例1"){:width=250 height=250}
##### summarise与group_by
`a %>% group_by(列1,列2,...)`按指定列分组，有相同列值的行为同一组
`a %>% summarise(新列1=列运算,...)`将多个值转换为单个值（通过`mean平均值`、`median中位数`、`n_distinct计算每组行数`等操作），生成新列（总行数减少，通常与`group_by`配合使用），结果中每一组的计算结果为一行
例：weather数据集
![summarise与group_by](https://pic1.zhimg.com/80/v2-56fc33210797fe9138bf7c8c09778d64_1440w.webp "summarise与group_by"){:width=250 height=250}
```
# 按city分组，计算温度的平均值，存入新列mean_temperature中
weather %>% group_by(city) %>% summarise(mean_temperature = mean(temperature))
```
![summarise与group_by例](https://pic4.zhimg.com/80/v2-ce6b704c8ee6890847a60141350938cb_1440w.webp "summarise与group_by例"){:width=125 height=125}
当不指定分组，直接summarise时，按所有数据为一组，即计算所有数据的平均值等
```
weather %>% summarise(mean_temperature = mean(temperature))
```
![summarise与group_by例2](https://pic2.zhimg.com/80/v2-7717371178297f50bd21a046e18b9a79_1440w.webp "summarise与group_by例2"){:width=100 height=100}

